
#include "DataTypes.cginc"

#pragma kernel Wall

RWStructuredBuffer<float2> positions;
RWStructuredBuffer<float2> velocities;
RWStructuredBuffer<float2> lastPositions;
StructuredBuffer<Wall> walls;

float timeStep;

[numthreads(PARTICLE_BLOCKSIZE, 1, 1)]
void Wall (uint3 id : SV_DispatchThreadID)
{
	uint i = id.x;
	uint N, _;
	float t;
	float2 wvector1, wvector2, pvector1, pvector2;
	int vsign1, vsign2;

	wall.GetDimensions(N, _);

	for (uint j = 1; j < N; j++) {

		//find out if we could have crossed line segment based on last position
		pvector1 = lastPositions[i] - wall[j - 1];
		pvector2 = lastPositions[i] - wall[j];

		if (sign(dot(pvector1, wall[j].norm)) != sign(dot(pvector2, wall[j].norm)))
			continue;
		//find out which side of the line we're on

		//+1, -1 indicates which side of the line we're on
		//http://stackoverflow.com/questions/1560492/how-to-tell-whether-a-point-is-to-the-right-or-left-side-of-a-line
		pvector1 = positions[i] - wall[j];
		pvector2 = lastPositions[i] - wall[j];
		wvector2 = wall[j].position - wall[j - 1].position;
		vsign1 = sign(wvector2[0] * pvector1[1] - wvector2[1] * pvector1[0]);
		vsign2 = sign(wvector2[0] * pvector2[1] - wvector2[1] * pvector2[0]);

		//check we crossed
		if (vsign1 != vsign2) {
			//we have to rewind the particle to be on the other side.
			// @ intersection wvector x (pvector + delta t * velocity) == 0
			//so delta t = w x p / p x v
			t = (wvector2[0] * pvector2[1] - wvector2[1] * pvector2[0]) / (wvector2[1] * velocities[i][0] - wvector2[0] * velocities[i][1]);
			
			//now rewind. t is negative
			positions += velocities * t;

			//now flip
			velocities -= 2 * dot(velocities, wall[j].norm) * wall[j].norm;

			//now integrate -> note that velocities have already been integrated
			positions += (timeStep + t) * velocities;
		}

	}

}
