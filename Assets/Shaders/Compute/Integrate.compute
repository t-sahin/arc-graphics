#include "DataTypes.cginc"



RWStructuredBuffer<float2> positions;
RWStructuredBuffer<float2> velocities;
RWStructuredBuffer<float2> forces;
RWStructuredBuffer<ParticleProperties> properties;

float timeStep = 0.01f;
float2 boundaryLow;
float2 boundaryHigh;

const static float2 moving_delta = { 0.0000001f, 0.0000001f };
const static float2 max_velocity = { 20.0f, 20.0f };
const static float2 neg_max_velocity = { -20.0f, -20.0f };


#pragma kernel Integrate1
[numthreads(PARTICLE_BLOCKSIZE,1,1)]
void Integrate1(uint3 id : SV_DispatchThreadID)
{
	uint i = id.x;
	forces[i] = 0;
	if (properties[i].alive) {
		velocities[i] += (0.5 * timeStep * forces[i]);
		velocities[i] = clamp(velocities[i], neg_max_velocity, max_velocity);
		positions[i] += (0.5 * timeStep * velocities[i]);

		//Check if the particle is stationary or out of bounds
		uint in_bounds = (uint) all(step(positions[i], boundaryHigh)) & all(step(boundaryLow, positions[i]));
		uint is_mobile = (uint) any(step(moving_delta, abs(velocities[i])));
		properties[i].alive = in_bounds;// &is_mobile;
	}
	
}

#pragma kernel Integrate2
[numthreads(PARTICLE_BLOCKSIZE, 1, 1)]
void Integrate2(uint3 id : SV_DispatchThreadID)
{
	uint i = id.x;
	if (properties[i].alive) {
		velocities[i] += (0.5 * timeStep * forces[i]);
		properties[i].life += timeStep;
		velocities[i] = clamp(velocities[i], neg_max_velocity, max_velocity);
	}
}

