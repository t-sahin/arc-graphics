#include "DataTypes.cginc"

#define SPAWN_BLOCKSIZE_X 4
#define SPAWN_BLOCKSIZE_Y 128


RWStructuredBuffer<float2> positions;
RWStructuredBuffer<float2> velocities;
RWStructuredBuffer<int> spawnTimers;
StructuredBuffer<Source> sources;
RWStructuredBuffer<ParticleProperties> properties;

groupshared int source_count;


#pragma kernel Spawn	
/*
* The block structure is spawn points by particles.
*/
[numthreads(SPAWN_BLOCKSIZE_X, SPAWN_BLOCKSIZE_Y, 1)]
void Spawn(uint3 id : SV_DispatchThreadID) {

	//check the timers to see if it's time to spawn
	uint ns, np, _;//throw away variable
	spawnTimers.GetDimensions(ns, _);
	properties.GetDimensions(np, _);

	if (id.y == 0) {
		source_count = 0;
		spawnTimers[id.x] += 1;
	}

	GroupMemoryBarrierWithGroupSync();

	//check if we need to spawn
	if (spawnTimers[id.x] % sources[id.x].spawn_period == 0) {

		//we are going to spawn
		//search particles along y thread id. This partitions the particles amongst the y threads
		int can_add = 0;
		int stride = ceil(((float)np) / SPAWN_BLOCKSIZE_Y);

		for (uint i = stride * id.y; i < min(np, stride * (id.y + 1)); i++) {
			//only can add if the particle is not in use.
			can_add += (properties[i].state == PARTICLE_STATE_DEAD);
		}

		//announce we're going to add as many as we can.
		int count;
		InterlockedAdd(source_count, can_add, count);
		//now, add as many as we need
		int to_add = can_add;
		//if we would add too many, remove them
		to_add -= max(0, (count + can_add) - sources[id.x].spawn_amount);

		//debug code for making sure we got a good number added
		//update what I'm going to add now
		to_add = max(to_add, 0);
		InterlockedAdd(source_count, -(can_add - to_add));
		/*
		if (to_add > 10 && count < 0) {
			positions[0] = float2(-5, 3);
			velocities[0] = float2(1, 1);
			properties[0].state = 1;
		}
		*/
		if (to_add > 0) {
			float lerp_s;
			for (i = stride * id.y; i < min(np, stride * (id.y + 1)); i++) {

				//go ahead and add now
				if (to_add > 0 && properties[i].state == PARTICLE_STATE_DEAD) {
					to_add -= 1;

					positions[i] = sources[id.x].position;
					//in theory, this should never need to be clamped. This code is so hard :(
					lerp_s = clamp((float)(count + to_add) / sources[id.x].spawn_amount, 0, 1);
					velocities[i] = lerp(sources[id.x].velocity_1, sources[id.x].velocity_2, float2(lerp_s, lerp_s));
					properties[i].state = PARTICLE_STATE_ALIVE;
					properties[i].life = sources[id.x].life_start;
					properties[i].color = float4(0, 0, 1, 1);
					properties[i].lastModifier = PARTICLE_MODIFIER_SPAWN;
					properties[i].lastModifierIndex = id.x;
				}
			}
		}

		//reset the sources count


		if (id.y == 0) {
			spawnTimers[id.x] = 0;
		}	
	}

	
	//GroupMemoryBarrierWithGroupSync();
	//Debug code for indicating if we got the correct number added.
	/*
	if (id.y == 5 && spawnTimers[id.x] % sources[id.x].spawn_period == 0 && sources[id.x].spawn_amount != source_count) {
		positions[0] = float2(25, 10);
		velocities[0] = float2(10, 10);
		properties[0].state = 1;
	}
	*/
	
}